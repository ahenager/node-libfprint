#!/usr/bin/env node
/// <reference path="../typings/tsd.d.ts"/>
var binary = require('node-pre-gyp');
var path = require('path');
var PACKAGE_JSON = path.join(__dirname, '../package.json');
var binding_path = binary.find(path.resolve(PACKAGE_JSON));
var fprintbinding = require(binding_path);

var stream = require('stream');
var util = require('util');
var bunyan = require('bunyan');
var events = require('events');

var log;

(function (fp_enroll_result) {
    fp_enroll_result[fp_enroll_result["ENROLL_COMPLETE"] = 1] = "ENROLL_COMPLETE";
    fp_enroll_result[fp_enroll_result["ENROLL_FAIL"] = 2] = "ENROLL_FAIL";
    fp_enroll_result[fp_enroll_result["ENROLL_PASS"] = 3] = "ENROLL_PASS";
    fp_enroll_result[fp_enroll_result["ENROLL_RETRY"] = 100] = "ENROLL_RETRY";
    fp_enroll_result[fp_enroll_result["ENROLL_RETRY_TOO_SHORT"] = 101] = "ENROLL_RETRY_TOO_SHORT";
    fp_enroll_result[fp_enroll_result["ENROLL_RETRY_CENTER_FINGER"] = 102] = "ENROLL_RETRY_CENTER_FINGER";
    fp_enroll_result[fp_enroll_result["ENROLL_RETRY_REMOVE_FINGER"] = 103] = "ENROLL_RETRY_REMOVE_FINGER";
    fp_enroll_result[fp_enroll_result["ENROLL_CANCELLED"] = 200] = "ENROLL_CANCELLED";
})(exports.fp_enroll_result || (exports.fp_enroll_result = {}));
var fp_enroll_result = exports.fp_enroll_result;

(function (fp_verify_result) {
    fp_verify_result[fp_verify_result["VERIFY_NO_MATCH"] = 0] = "VERIFY_NO_MATCH";
    fp_verify_result[fp_verify_result["VERIFY_MATCH"] = 1] = "VERIFY_MATCH";
    fp_verify_result[fp_verify_result["VERIFY_RETRY"] = 100] = "VERIFY_RETRY";
    fp_verify_result[fp_verify_result["VERIFY_RETRY_TOO_SHORT"] = 101] = "VERIFY_RETRY_TOO_SHORT";
    fp_verify_result[fp_verify_result["VERIFY_RETRY_CENTER_FINGER"] = 102] = "VERIFY_RETRY_CENTER_FINGER";
    fp_verify_result[fp_verify_result["VERIFY_RETRY_REMOVE_FINGER"] = 103] = "VERIFY_RETRY_REMOVE_FINGER";
    fp_verify_result[fp_verify_result["VERIFY_CANCELLED"] = 200] = "VERIFY_CANCELLED";
})(exports.fp_verify_result || (exports.fp_verify_result = {}));
var fp_verify_result = exports.fp_verify_result;

(function (fp_stop_result) {
    fp_stop_result[fp_stop_result["STOP_SUCCESS"] = 1] = "STOP_SUCCESS";
    fp_stop_result[fp_stop_result["STOP_FAIL"] = 2] = "STOP_FAIL";
    fp_stop_result[fp_stop_result["STOP_IGNORE"] = 3] = "STOP_IGNORE";
})(exports.fp_stop_result || (exports.fp_stop_result = {}));
var fp_stop_result = exports.fp_stop_result;

var fpreader = (function () {
    function fpreader(fpinstance) {
        var _this = this;
        this.close = function () {
            _this.wrapped.close();
        };
        // update the database
        this.update_database = function (fplist) {
            _this.wrapped.update_database(fplist);
        };
        // Start enrolling a fingerprint
        this.start_enroll = function (callback) {
            // tell the fpreader to begin the enroll finger process
            if (!_this.wrapped.enroll_finger(function (result, fpdata, fpimage, height, width) {
                var err = null;

                // If the result was not a successful enrollment
                if (result != 1 /* ENROLL_COMPLETE */) {
                    // store error code in err
                    err = fp_enroll_result[result];
                    callback(err, null, null, null, null, null);
                } else {
                    // check the fpdata for completeness
                    if (fpdata !== null && fpdata !== undefined) {
                        var data = fpdata;
                    }

                    // shouldn't we check these as well? TODO
                    var image = new Buffer(fpimage.length);
                    fpimage.copy(image);

                    // callback to fp_server
                    callback(err, result, data, image, height, width);
                }
            })) {
                // Not finished yet!
                callback("Enroll in progress!", null, null, null, null, null);
            }
        };
        // Stop enrolling a fingerprint
        this.stop_enroll = function (callback) {
            // tell the fp.reader to stop enrollment (if it is enrolling)
            _this.wrapped.stop_enroll_finger(function (result) {
                var err = null;
                if (result == 1 /* STOP_SUCCESS */) {
                    callback(err, true);
                } else {
                    err = fp_stop_result[result];
                    callback(err, null);
                }
            });
        };
        // ******TODO figure out how to pass an argument down here
        // Start identifying a fingerprint
        this.start_identify = function (callback) {
            // tell the fpreader to begin the identify finger process
            if (!_this.wrapped.identify_finger(function (result, fpindex, fpimage, height, width) {
                var err = null;

                // If the result was not successful
                if (result != 1 /* VERIFY_MATCH */) {
                    // store error code in err
                    err = fp_verify_result[result];
                    callback(err, null, null, null, null, null);
                } else {
                    // shouldn't we check these as well? TODO
                    var image = new Buffer(fpimage.length);
                    fpimage.copy(image);

                    // callback to fp_server
                    callback(err, result, fpindex, image, height, width);
                }
            })) {
                // Not finished yet!
                callback("Identify in progress!", null, null, null, null, null);
            }
        };
        // Stop identifying a fingerprint
        this.stop_identify = function (callback) {
            // tell the fp.reader to stop identification (if it is identifying)
            _this.wrapped.stop_identify_finger(function (result) {
                var err = null;
                if (result == 1 /* STOP_SUCCESS */) {
                    callback(err, true);
                } else {
                    err = fp_stop_result[result];
                    callback(err, null);
                }
            });
        };
        // Driver for async fingerprint activity
        this.handle_events = function () {
            // tell the fp.reader to handle events, i.e. advance the reader a step
            _this.wrapped.handle_events();
        };
        this.wrapped = fpinstance;

        //these values are static so we can grab them now
        this.enroll_stages = fpinstance.enroll_stages;
        this.supports_imaging = fpinstance.supports_imaging;
        this.supports_identification = fpinstance.supports_identification;
        this.img_width = fpinstance.img_width;
        this.img_height = fpinstance.img_height;
    }
    return fpreader;
})();
exports.fpreader = fpreader;

var fprint = (function () {
    function fprint() {
    }
    // Initializes libfprint and returns 0 if successful.
    fprint.prototype.init = function () {
        return fprintbinding.init();
    };

    fprint.prototype.discover = function () {
        var devices = [];
        fprintbinding.discover(function (handle, devid, drvtype, drvname, drvfullname) {
            var thisdev = {
                handle: handle,
                deviceid: devid,
                driver_type: drvtype,
                driver: drvname,
                driver_detail: drvfullname
            };

            devices.push(thisdev);
        });

        return devices;
    };

    fprint.prototype.get_reader = function (handle) {
        var reader = new fprintbinding.fpreader(handle);
        if (typeof reader != 'undefined') {
            return new fpreader(reader);
        }
        return null;
    };

    fprint.prototype.exit = function () {
        return fprintbinding.exit();
    };
    return fprint;
})();
exports.fprint = fprint;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYmZwcmludC50cyJdLCJuYW1lcyI6WyJmcF9lbnJvbGxfcmVzdWx0IiwiZnBfdmVyaWZ5X3Jlc3VsdCIsImZwX3N0b3BfcmVzdWx0IiwiZnByZWFkZXIiLCJmcHJlYWRlci5jb25zdHJ1Y3RvciIsImZwcmludCIsImZwcmludC5jb25zdHJ1Y3RvciIsImZwcmludC5pbml0IiwiZnByaW50LmRpc2NvdmVyIiwiZnByaW50LmdldF9yZWFkZXIiLCJmcHJpbnQuZXhpdCJdLCJtYXBwaW5ncyI6IkFBQUEsMkNBQTJDO0FBQTNDLElBRUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDcEMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUMxQixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsQ0FBQztBQUMxRCxJQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDMUQsSUFBSSxhQUFhLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQzs7QUFFekMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztBQUM5QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQzFCLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDOUIsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQzs7QUFFOUIsSUFBSSxHQUFHOztDQUVQLFVBQVksZ0JBQWdCO0lBRXhCQSx1REFBa0JBLENBQUNBLHFCQUFBQTtJQUNuQkEsbURBQWNBLENBQUNBLGlCQUFBQTtJQUNmQSxtREFBY0EsQ0FBQ0EsaUJBQUFBO0lBQ2ZBLG9EQUFlQSxHQUFHQSxrQkFBQUE7SUFDbEJBLDhEQUF5QkEsR0FBR0EsNEJBQUFBO0lBQzVCQSxrRUFBNkJBLEdBQUdBLGdDQUFBQTtJQUNoQ0Esa0VBQTZCQSxH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QUNBO0FBQURBLENBQUNBLElBQUE7QUF2Q0Qsd0JBdUNDO0FBQ0QiLCJmaWxlIjoibGliZnByaW50LmpzIiwic291cmNlUm9vdCI6Ii9ob21lL2Flcm8vbm9kZS1saWJmcHJpbnQvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL3R5cGluZ3MvdHNkLmQudHNcIi8+XG5cbnZhciBiaW5hcnkgPSByZXF1aXJlKCdub2RlLXByZS1neXAnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIFBBQ0tBR0VfSlNPTiA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9wYWNrYWdlLmpzb24nKTtcbnZhciBiaW5kaW5nX3BhdGggPSBiaW5hcnkuZmluZChwYXRoLnJlc29sdmUoUEFDS0FHRV9KU09OKSk7XG52YXIgZnByaW50YmluZGluZyA9IHJlcXVpcmUoYmluZGluZ19wYXRoKTtcblxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYnVueWFuID0gcmVxdWlyZSgnYnVueWFuJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBsb2c7XG5cbmV4cG9ydCBlbnVtIGZwX2Vucm9sbF9yZXN1bHRcbntcbiAgICBFTlJPTExfQ09NUExFVEUgPSAxLFxuICAgIEVOUk9MTF9GQUlMID0gMixcbiAgICBFTlJPTExfUEFTUyA9IDMsXG4gICAgRU5ST0xMX1JFVFJZID0gMTAwLFxuICAgIEVOUk9MTF9SRVRSWV9UT09fU0hPUlQgPSAxMDEsXG4gICAgRU5ST0xMX1JFVFJZX0NFTlRFUl9GSU5HRVIgPSAxMDIsXG4gICAgRU5ST0xMX1JFVFJZX1JFTU9WRV9GSU5HRVIgPSAxMDMsXG4gICAgRU5ST0xMX0NBTkNFTExFRCA9IDIwMCAvLyBjdXN0b20sIGZvciBhc3luY1xufVxuXG5leHBvcnQgZW51bSBmcF92ZXJpZnlfcmVzdWx0XG57IFxuICAgIFZFUklGWV9OT19NQVRDSCA9IDAsIFxuICAgIFZFUklGWV9NQVRDSCA9IDEsIFxuICAgIFZFUklGWV9SRVRSWSA9IDEwMCwgXG4gICAgVkVSSUZZX1JFVFJZX1RPT19TSE9SVCA9IDEwMSwgXG4gICAgVkVSSUZZX1JFVFJZX0NFTlRFUl9GSU5HRVIgPSAxMDIsIFxuICAgIFZFUklGWV9SRVRSWV9SRU1PVkVfRklOR0VSID0gMTAzLFxuICAgIFZFUklGWV9DQU5DRUxMRUQgPSAyMDAgLy8gY3VzdG9tLCBmb3IgYXN5bmNcbn1cblxuZXhwb3J0IGVudW0gZnBfc3RvcF9yZXN1bHRcbntcbiAgICBTVE9QX1NVQ0NFU1MgPSAxLFxuICAgIFNUT1BfRkFJTCA9IDIsXG4gICAgU1RPUF9JR05PUkUgPSAzXG59XG5cbmV4cG9ydCBjbGFzcyBmcHJlYWRlciB7XG4gICAgcHJpdmF0ZSB3cmFwcGVkO1xuXG4gICAgZW5yb2xsX3N0YWdlcyA6IG51bWJlcjtcbiAgICBzdXBwb3J0c19pbWFnaW5nIDogYm9vbGVhbjtcbiAgICBzdXBwb3J0c19pZGVudGlmaWNhdGlvbjogYm9vbGVhbjtcbiAgICBpbWdfd2lkdGg6IG51bWJlcjtcbiAgICBpbWdfaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy53cmFwcGVkLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBkYXRhYmFzZVxuICAgIHVwZGF0ZV9kYXRhYmFzZSA9IChmcGxpc3Q6IHN0cmluZ1tdKSA6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLndyYXBwZWQudXBkYXRlX2RhdGFiYXNlKGZwbGlzdCk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgZW5yb2xsaW5nIGEgZmluZ2VycHJpbnRcbiAgICBzdGFydF9lbnJvbGwgPSAoY2FsbGJhY2sgOiAoZXJyLCByZXN1bHQgOiBmcF9lbnJvbGxfcmVzdWx0LCBmcGRhdGEgOiBTdHJpbmcsIGZwaW1hZ2U6IEJ1ZmZlciwgaGVpZ2h0IDogTnVtYmVyLCB3aWR0aCA6IE51bWJlcikgPT4gdm9pZCkgOiB2b2lkID0+IHtcbiAgICBcbiAgICAgICAgLy8gdGVsbCB0aGUgZnByZWFkZXIgdG8gYmVnaW4gdGhlIGVucm9sbCBmaW5nZXIgcHJvY2Vzc1xuICAgICAgICBpZiAoIXRoaXMud3JhcHBlZC5lbnJvbGxfZmluZ2VyKFxuICAgICAgICAgICAgICAgIC8vIEVucm9sbCBmaW5nZXIgaGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXN1bHQ6IGZwX2Vucm9sbF9yZXN1bHQsIGZwZGF0YSwgZnBpbWFnZSwgaGVpZ2h0IDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCB3YXMgbm90IGEgc3VjY2Vzc2Z1bCBlbnJvbGxtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gZnBfZW5yb2xsX3Jlc3VsdC5FTlJPTExfQ09NUExFVEUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGVycm9yIGNvZGUgaW4gZXJyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBmcF9lbnJvbGxfcmVzdWx0W3Jlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGZwZGF0YSBmb3IgY29tcGxldGVuZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnBkYXRhICE9PSBudWxsICYmIGZwZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZnBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGRuJ3Qgd2UgY2hlY2sgdGhlc2UgYXMgd2VsbD8gVE9ET1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IEJ1ZmZlcihmcGltYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcGltYWdlLmNvcHkoaW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayB0byBmcF9zZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0LCBkYXRhLCBpbWFnZSwgaGVpZ2h0LCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIC8vIE5vdCBmaW5pc2hlZCB5ZXQhXG4gICAgICAgICAgICBjYWxsYmFjayhcIkVucm9sbCBpbiBwcm9ncmVzcyFcIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdG9wIGVucm9sbGluZyBhIGZpbmdlcnByaW50XG4gICAgc3RvcF9lbnJvbGwgPSAoY2FsbGJhY2sgOiAoZXJyLHJlc3VsdCkgPT4gdm9pZCkgOiB2b2lkID0+IHtcbiAgICAgICAgLy8gdGVsbCB0aGUgZnAucmVhZGVyIHRvIHN0b3AgZW5yb2xsbWVudCAoaWYgaXQgaXMgZW5yb2xsaW5nKVxuICAgICAgICB0aGlzLndyYXBwZWQuc3RvcF9lbnJvbGxfZmluZ2VyKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdDogZnBfc3RvcF9yZXN1bHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBmcF9zdG9wX3Jlc3VsdC5TVE9QX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBmcF9zdG9wX3Jlc3VsdFtyZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyAqKioqKipUT0RPIGZpZ3VyZSBvdXQgaG93IHRvIHBhc3MgYW4gYXJndW1lbnQgZG93biBoZXJlXG5cbiAgICAvLyBTdGFydCBpZGVudGlmeWluZyBhIGZpbmdlcnByaW50XG4gICAgc3RhcnRfaWRlbnRpZnkgPSAoY2FsbGJhY2sgOiAoZXJyLCByZXN1bHQgOiBmcF92ZXJpZnlfcmVzdWx0LCBmcGluZGV4IDogTnVtYmVyLCBmcGltYWdlOiBCdWZmZXIsIGhlaWdodCA6IE51bWJlciwgd2lkdGggOiBOdW1iZXIpID0+IHZvaWQpIDogdm9pZCA9PiB7XG4gICAgXG4gICAgICAgIC8vIHRlbGwgdGhlIGZwcmVhZGVyIHRvIGJlZ2luIHRoZSBpZGVudGlmeSBmaW5nZXIgcHJvY2Vzc1xuICAgICAgICBpZiAoIXRoaXMud3JhcHBlZC5pZGVudGlmeV9maW5nZXIoIC8vICoqKioqIFRPRE8gcGFzcyBpbiB0aGUgbGlzdCBhcmdcbiAgICAgICAgICAgICAgICAvLyBJZGVudGlmeSBmaW5nZXIgaGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXN1bHQ6IGZwX3ZlcmlmeV9yZXN1bHQsIGZwaW5kZXgsIGZwaW1hZ2UsIGhlaWdodCA6IG51bWJlciwgd2lkdGg6IG51bWJlcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgd2FzIG5vdCBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gZnBfdmVyaWZ5X3Jlc3VsdC5WRVJJRllfTUFUQ0gpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGVycm9yIGNvZGUgaW4gZXJyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBmcF92ZXJpZnlfcmVzdWx0W3Jlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkbid0IHdlIGNoZWNrIHRoZXNlIGFzIHdlbGw/IFRPRE9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBCdWZmZXIoZnBpbWFnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnBpbWFnZS5jb3B5KGltYWdlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgdG8gZnBfc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCwgZnBpbmRleCwgaW1hZ2UsIGhlaWdodCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICApKSB7XG4gICAgICAgICAgICAvLyBOb3QgZmluaXNoZWQgeWV0IVxuICAgICAgICAgICAgY2FsbGJhY2soXCJJZGVudGlmeSBpbiBwcm9ncmVzcyFcIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdG9wIGlkZW50aWZ5aW5nIGEgZmluZ2VycHJpbnRcbiAgICBzdG9wX2lkZW50aWZ5ID0gKGNhbGxiYWNrIDogKGVycixyZXN1bHQpID0+IHZvaWQpIDogdm9pZCA9PiB7XG4gICAgICAgIC8vIHRlbGwgdGhlIGZwLnJlYWRlciB0byBzdG9wIGlkZW50aWZpY2F0aW9uIChpZiBpdCBpcyBpZGVudGlmeWluZylcbiAgICAgICAgdGhpcy53cmFwcGVkLnN0b3BfaWRlbnRpZnlfZmluZ2VyKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdDogZnBfc3RvcF9yZXN1bHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBmcF9zdG9wX3Jlc3VsdC5TVE9QX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBmcF9zdG9wX3Jlc3VsdFtyZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEcml2ZXIgZm9yIGFzeW5jIGZpbmdlcnByaW50IGFjdGl2aXR5XG4gICAgaGFuZGxlX2V2ZW50cyA9ICgpIDogdm9pZCA9PiB7XG4gICAgICAgIC8vIHRlbGwgdGhlIGZwLnJlYWRlciB0byBoYW5kbGUgZXZlbnRzLCBpLmUuIGFkdmFuY2UgdGhlIHJlYWRlciBhIHN0ZXBcbiAgICAgICAgdGhpcy53cmFwcGVkLmhhbmRsZV9ldmVudHMoKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihmcGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZCA9IGZwaW5zdGFuY2U7XG5cbiAgICAgICAgLy90aGVzZSB2YWx1ZXMgYXJlIHN0YXRpYyBzbyB3ZSBjYW4gZ3JhYiB0aGVtIG5vd1xuICAgICAgICB0aGlzLmVucm9sbF9zdGFnZXMgPSBmcGluc3RhbmNlLmVucm9sbF9zdGFnZXM7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNfaW1hZ2luZyA9IGZwaW5zdGFuY2Uuc3VwcG9ydHNfaW1hZ2luZztcbiAgICAgICAgdGhpcy5zdXBwb3J0c19pZGVudGlmaWNhdGlvbiA9IGZwaW5zdGFuY2Uuc3VwcG9ydHNfaWRlbnRpZmljYXRpb247XG4gICAgICAgIHRoaXMuaW1nX3dpZHRoID0gZnBpbnN0YW5jZS5pbWdfd2lkdGg7XG4gICAgICAgIHRoaXMuaW1nX2hlaWdodCA9IGZwaW5zdGFuY2UuaW1nX2hlaWdodDtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBmcHJpbnQge1xuXG4gICAgLy8gSW5pdGlhbGl6ZXMgbGliZnByaW50IGFuZCByZXR1cm5zIDAgaWYgc3VjY2Vzc2Z1bC5cbiAgICBpbml0KCkgOiBudW1iZXIgIHtcbiAgICAgICAgcmV0dXJuIGZwcmludGJpbmRpbmcuaW5pdCgpO1xuICAgIH1cblxuICAgIGRpc2NvdmVyKCkge1xuICAgICAgICB2YXIgZGV2aWNlcyA9IFtdO1xuICAgICAgICBmcHJpbnRiaW5kaW5nLmRpc2NvdmVyKCBmdW5jdGlvbihoYW5kbGUsIGRldmlkLCBkcnZ0eXBlLCBkcnZuYW1lLCBkcnZmdWxsbmFtZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzZGV2ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VpZDogZGV2aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcml2ZXJfdHlwZTogZHJ2dHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaXZlcjogZHJ2bmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyaXZlcl9kZXRhaWw6IGRydmZ1bGxuYW1lXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlcy5wdXNoKHRoaXNkZXYpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgIH1cblxuICAgIGdldF9yZWFkZXIoaGFuZGxlOiBudW1iZXIpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBmcHJpbnRiaW5kaW5nLmZwcmVhZGVyKGhhbmRsZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVhZGVyICE9ICd1bmRlZmluZWQnKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGZwcmVhZGVyKHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZXhpdCgpIDogdm9pZCB7XG4gICAgICAgIHJldHVybiBmcHJpbnRiaW5kaW5nLmV4aXQoKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvciAoKSB7IH1cbn1cbiJdfQ==